#N canvas 343 67 942 368 12;
#X declare -path else;
#X obj 688 221 downsample~;
#X obj 778 81 initmess \; \$0-sr 44100;
#X obj 541 208 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 44100 256;
#X obj 544 185 hsl 100 15 400 44099 1 0 empty \$0-sr empty -2 -8 0
10 -228856 -1 -1 9900 1;
#X text 601 208 Hertz;
#X obj 499 267 out~;
#X obj 499 231 sh~;
#X obj 541 232 impulse~;
#X obj 762 200 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10
-228856 -1 -1 44100 256;
#X obj 765 177 hsl 100 15 400 44099 1 0 empty \$0-sr empty -2 -8 0
10 -228856 -1 -1 9900 1;
#X text 820 198 Hertz;
#X obj 688 257 out~;
#X obj 482 120 send~ \$0-audio;
#X obj 499 161 receive~ \$0-audio;
#X obj 688 147 receive~ \$0-audio;
#X text 34 58 We can still perform downsampling if we do not actually
reduce the sample rate \, but we need to do an upsampling to go back
to the original sample rate., f 59;
#X text 34 113 In the upsampling process \, there aren't that many
options. One is to "hold" \, where we keep the same value for all the
new sample values. One way to implement this is with [sh~] \, from
ELSE \, which is a "sample and hold" unit that collects a sample value
when receiving impulses and holds such values until the next trigger.
The frequency at wich it receives impulses is the downsampled frequency.
, f 59;
#X text 35 221 A simpler alternative is to use [downsample~] from ELSE
\, which only needs a downsampling frequency value., f 59;
#X text 483 55 [play.file~] plays audio files;
#X obj 757 24 declare -path else;
#X obj 482 81 play.file~ bubul.wav 1 1;
#X text 34 18 The "decimator" is a process that consist in reducing
the sample rate of a signal - also known as "downsampling".;
#X connect 0 0 11 0;
#X connect 0 0 11 1;
#X connect 2 0 7 0;
#X connect 3 0 2 0;
#X connect 6 0 5 0;
#X connect 6 0 5 1;
#X connect 7 0 6 1;
#X connect 8 0 0 1;
#X connect 9 0 8 0;
#X connect 13 0 6 0;
#X connect 14 0 0 0;
#X connect 20 0 12 0;
