#N canvas 365 31 750 629 12;
#X declare -path else;
#X obj 258 497 *~;
#X obj 276 357 vline~;
#X obj 128 216 t f f;
#X obj 128 271 pack;
#X obj 160 242 * 0.5;
#X obj 128 90 == 0;
#X obj 185 389 osc~ 440;
#X obj 215 539 out~;
#X msg 276 297 0 250;
#X msg 128 297 \$1 150 \, \$2 100 150;
#X obj 128 32 tgl 18 0 empty empty empty 17 7 0 10 -228856 -1 -1 0
1;
#X msg 415 297 250;
#X msg 378 297 100;
#X text 336 296 decay;
#X text 440 296 release;
#X obj 128 63 trigger float float, f 28;
#X obj 128 188 float;
#X obj 128 118 select 0 1;
#X obj 378 346 expr 1000./$f1;
#X text 510 411 attack;
#X obj 276 459 slop~ 1e+09, f 15;
#X obj 395 381 loadbang;
#X obj 395 410 expr 1000./150.;
#X text 34 257 gate/sustain values =====>, f 13;
#X obj 444 232 adsr~ 150 100 0.5 250 -slew;
#X text 378 87 Here's how to implement an ADSR exponential envelope
with vanilla. We use again the [slop~] object for that. We need to
calculate the sustain point from the gate input value and also take
care to set different downward periods for the decay and release part.
The patch to the left relates to the [adsr~] object with the parameters
below., f 43;
#X obj 535 35 declare -path else;
#X connect 0 0 7 0;
#X connect 0 0 7 1;
#X connect 1 0 20 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 9 0;
#X connect 4 0 3 1;
#X connect 5 0 17 0;
#X connect 6 0 0 0;
#X connect 8 0 1 0;
#X connect 9 0 1 0;
#X connect 10 0 15 0;
#X connect 11 0 18 0;
#X connect 12 0 18 0;
#X connect 15 0 5 0;
#X connect 15 1 16 1;
#X connect 16 0 2 0;
#X connect 17 0 16 0;
#X connect 17 0 12 0;
#X connect 17 1 8 0;
#X connect 17 1 11 0;
#X connect 18 0 20 5;
#X connect 20 0 0 1;
#X connect 21 0 22 0;
#X connect 22 0 20 3;
