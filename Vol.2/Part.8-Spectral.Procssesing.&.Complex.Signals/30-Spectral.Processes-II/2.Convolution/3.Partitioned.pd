#N canvas 454 324 1036 484 12;
#X obj 68 370 cnv 15 418 78 empty empty empty 20 12 0 14 -233017 -66577
0;
#N canvas 0 22 450 300 (subpatch) 0;
#X array \$0-IR 16384 float 2;
#X coords 0 1 16384 -1 420 80 1 0 0;
#X restore 67 369 graph;
#X obj 84 318 soundfiler;
#X obj 623 125 s~ \$0-input;
#X obj 791 130 bng 17 250 50 0 empty empty empty 17 7 0 10 -228856
-1 -1;
#X obj 791 156 tabplay~ \$0-IR;
#X obj 791 194 out~;
#X text 815 130 Play IR:;
#X obj 560 158 out~;
#X obj 686 334 r~ \$0-input;
#X obj 686 405 out~;
#X obj 603 83 play.file~ 1 ../../../../samples/didge.aif 1 1;
#X obj 84 286 initmess read -resize ../../../../samples/IR.wav \$0-IR
;
#X obj 686 366 conv~ 512 ../../../../samples/IR.wav;
#X text 60 35 Partitioned convolution divides the IR into smaller bits
so we get much shorter latencies suitable for live input. The convolution
is done in each partition separately.;
#X text 65 94 We can implement this in a Pd patch by loading different
instances of each partition inside [clone]. In this way \, an input
is convoluted to all partitions at the same time \, but they're delayed
accordingly so they get added at the right time.;
#X text 64 177 The [conv~] object from the ELSE library is an abstraction
that implements partitioned convolution this way. It needs a partition
size and an audio file to load as an IR. Below we load the same IR
file into a table just so we can listen to it separately.;
#X text 562 33 Play the input sound and the IR below:;
#X text 546 272 And now for the paritioned convolution with a partition
size of 512 samples. See the help file of [conv~] for more details.
;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 5 0 6 1;
#X connect 9 0 13 0;
#X connect 11 0 3 0;
#X connect 11 0 8 1;
#X connect 11 0 8 0;
#X connect 12 0 2 0;
#X connect 13 0 10 0;
#X connect 13 0 10 1;
